<!DOCTYPE html>
<html>
<head>
    <title>Snow Background</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        
        #groundCanvas,
        #snowCanvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100dvh;
            pointer-events: none;
            z-index: 5;
        }
    </style>
</head>
<body>
    <canvas id="groundCanvas"></canvas>
    <canvas id="snowCanvas"></canvas>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // キャンバス要素の取得
            const groundCanvas = document.getElementById('groundCanvas');
            const snowCanvas = document.getElementById('snowCanvas');
            const snowCtx = snowCanvas.getContext('2d');
            const groundCtx = groundCanvas.getContext('2d');

            // 雪と地面の雪の配列
            let leaves = [];
            let groundLeaves = [];

            // スクロール位置を取得する関数
            const getScrollProgress = () => {
                const scrollHeight = document.documentElement.scrollHeight - window.innerHeight;
                const currentScroll = window.scrollY;
                return Math.min(currentScroll / scrollHeight, 1);
            };

            // スクロール位置に基づいて雪の透明度を決定
            const getSnowColor = (scrollProgress = null) => {
                const progress = scrollProgress !== null ? scrollProgress : getScrollProgress();
                
                // 雪は白で、透明度のみ変化
                const opacity = 0.6 + Math.random() * 0.3;
                return `rgba(180, 220, 255, ${opacity})`;
            };

            // キャンバスのリサイズ処理
            const resizeCanvas = () => {
                const fullHeight = window.innerHeight;
                snowCanvas.width = window.innerWidth;
                snowCanvas.height = fullHeight;
                groundCanvas.width = window.innerWidth;
                groundCanvas.height = fullHeight;
            };

            // 初期化
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // 雪の生成（画面中央を避ける）
            const createSnow = (x = null, y = null) => {
                let snowX;

                if (x !== null) {
                    snowX = x;
                } else {
                    // 画面中央を避けて左右どちらかに生成
                    const centerZone = snowCanvas.width * 0.6; // 中央60%を避ける
                    const leftZone = (snowCanvas.width - centerZone) / 2;
                    const rightZoneStart = leftZone + centerZone;

                    if (Math.random() < 0.5) {
                        // 左側に生成
                        snowX = Math.random() * leftZone;
                    } else {
                        // 右側に生成
                        snowX = rightZoneStart + Math.random() * leftZone;
                    }
                }

                const snowY = y !== null ? y : -30;
                const size = 5 + Math.random() * 10;
                const speed = 0.5 + Math.random() * 1.5;
                const swaySpeed = 0.02 + Math.random() * 0.03;
                const swayAmount = 30 + Math.random() * 40;
                const rotation = Math.random() * Math.PI * 2;
                const rotationSpeed = (Math.random() - 0.5) * 0.04;
                const color = getSnowColor();

                leaves.push({
                    x: snowX,
                    y: snowY,
                    initialX: snowX,
                    size,
                    speed,
                    swaySpeed,
                    swayAmount,
                    swayOffset: Math.random() * Math.PI * 2,
                    rotation,
                    rotationSpeed,
                    color,
                    type: Math.random() // 雪の形のバリエーション用
                });
            };

            // 地面に落ちた雪の追加
            const addGroundSnow = (x, y, color, size, type) => {
                groundLeaves.push({
                    x,
                    y,
                    color,
                    size,
                    rotation: Math.random() * Math.PI * 2,
                    opacity: 0.5,
                    fadeSpeed: 0.01 + Math.random() * 0.02, // 徐々に透明になる速度
                    type
                });

                if (groundLeaves.length > 50) {
                    groundLeaves.shift();
                }
            };

            // 自然な雪の結晶を描画
            const drawSnow = (ctx, x, y, size, rotation, color, type) => {
                ctx.save();
                ctx.translate(x, y);
                ctx.rotate(rotation);

                const branches = 6; // 雪の結晶は6方向が基本
                const opacity = parseFloat(color.match(/[\d.]+(?=\))/)[0]);

                ctx.strokeStyle = color;
                ctx.fillStyle = color;
                ctx.lineWidth = size * 0.08;
                ctx.lineCap = 'round';

                if (type < 0.3) {
                    // タイプ1: シンプルな六角形の雪
                    ctx.beginPath();
                    for (let i = 0; i < branches; i++) {
                        const angle = (Math.PI * 2 / branches) * i;
                        const x1 = Math.cos(angle) * size * 0.5;
                        const y1 = Math.sin(angle) * size * 0.5;
                        
                        if (i === 0) ctx.moveTo(x1, y1);
                        else ctx.lineTo(x1, y1);
                    }
                    ctx.closePath();
                    ctx.stroke();
                    
                    // 中心の点
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.15, 0, Math.PI * 2);
                    ctx.fill();
                } else if (type < 0.7) {
                    // タイプ2: 枝分かれのある雪の結晶
                    for (let i = 0; i < branches; i++) {
                        const angle = (Math.PI * 2 / branches) * i;
                        
                        ctx.save();
                        ctx.rotate(angle);
                        
                        // 主軸
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(0, -size * 0.6);
                        ctx.stroke();
                        
                        // 側枝
                        const branchCount = 2;
                        for (let j = 1; j <= branchCount; j++) {
                            const pos = -size * 0.2 * j;
                            const branchLen = size * 0.15 * (branchCount - j + 1) / branchCount;
                            
                            ctx.beginPath();
                            ctx.moveTo(0, pos);
                            ctx.lineTo(-branchLen * Math.cos(Math.PI / 6), pos - branchLen * Math.sin(Math.PI / 6));
                            ctx.moveTo(0, pos);
                            ctx.lineTo(branchLen * Math.cos(Math.PI / 6), pos - branchLen * Math.sin(Math.PI / 6));
                            ctx.stroke();
                        }
                        
                        ctx.restore();
                    }
                    
                    // 中心部
                    ctx.beginPath();
                    ctx.arc(0, 0, size * 0.1, 0, Math.PI * 2);
                    ctx.fill();
                } else {
                    // タイプ3: 複雑な樹枝状雪結晶
                    for (let i = 0; i < branches; i++) {
                        const angle = (Math.PI * 2 / branches) * i;
                        
                        ctx.save();
                        ctx.rotate(angle);
                        
                        // 主軸
                        ctx.beginPath();
                        ctx.moveTo(0, 0);
                        ctx.lineTo(0, -size * 0.7);
                        ctx.stroke();
                        
                        // 複雑な側枝パターン
                        for (let j = 1; j <= 3; j++) {
                            const pos = -size * 0.18 * j;
                            const branchLen = size * (0.25 - j * 0.05);
                            
                            // 主側枝
                            for (let side of [-1, 1]) {
                                ctx.beginPath();
                                ctx.moveTo(0, pos);
                                ctx.lineTo(
                                    side * branchLen * Math.cos(Math.PI / 6),
                                    pos - branchLen * Math.sin(Math.PI / 6)
                                );
                                ctx.stroke();
                                
                                // 副側枝
                                const subLen = branchLen * 0.4;
                                ctx.beginPath();
                                ctx.moveTo(
                                    side * branchLen * 0.6 * Math.cos(Math.PI / 6),
                                    pos - branchLen * 0.6 * Math.sin(Math.PI / 6)
                                );
                                ctx.lineTo(
                                    side * (branchLen * 0.6 * Math.cos(Math.PI / 6) + subLen * Math.cos(Math.PI / 4)),
                                    pos - (branchLen * 0.6 * Math.sin(Math.PI / 6) + subLen * Math.sin(Math.PI / 4))
                                );
                                ctx.stroke();
                            }
                        }
                        
                        // 先端の装飾
                        ctx.beginPath();
                        ctx.arc(0, -size * 0.7, size * 0.08, 0, Math.PI * 2);
                        ctx.fill();
                        
                        ctx.restore();
                    }
                    
                    // 中心の六角形
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = (Math.PI * 2 / 6) * i;
                        const x1 = Math.cos(angle) * size * 0.12;
                        const y1 = Math.sin(angle) * size * 0.12;
                        if (i === 0) ctx.moveTo(x1, y1);
                        else ctx.lineTo(x1, y1);
                    }
                    ctx.closePath();
                    ctx.fill();
                }

                ctx.restore();
            };

            // 雪の更新と描画
            const updateLeaves = () => {
                snowCtx.clearRect(0, 0, snowCanvas.width, snowCanvas.height);

                // 新しい雪を生成
                if (Math.random() < 0.06 && leaves.length < 40) {
                    createSnow();
                }

                // 既存の雪を更新
                for (let i = leaves.length - 1; i >= 0; i--) {
                    const snow = leaves[i];

                    // 落下と横揺れ
                    snow.y += snow.speed;
                    snow.swayOffset += snow.swaySpeed;
                    snow.x = snow.initialX + Math.sin(snow.swayOffset) * snow.swayAmount;

                    // 回転
                    snow.rotation += snow.rotationSpeed;

                    // 地面に到達したら
                    if (snow.y >= snowCanvas.height * 0.95) {
                        addGroundSnow(snow.x, snowCanvas.height * 0.95, snow.color, snow.size, snow.type);
                        leaves.splice(i, 1);
                        continue;
                    }

                    // 雪を描画
                    drawSnow(snowCtx, snow.x, snow.y, snow.size, snow.rotation, snow.color, snow.type);
                }
            };

            // 地面の雪の更新と描画
            const updateGroundLeaves = () => {
                groundCtx.clearRect(0, 0, groundCanvas.width, groundCanvas.height);

                for (let i = groundLeaves.length - 1; i >= 0; i--) {
                    const snow = groundLeaves[i];
                    snow.opacity -= snow.fadeSpeed;

                    if (snow.opacity <= 0) {
                        groundLeaves.splice(i, 1);
                        continue;
                    }

                    // 地面の雪は透明度を上書き
                    const colorWithOpacity = `rgba(255, 255, 255, ${snow.opacity})`;
                    drawSnow(groundCtx, snow.x, snow.y, snow.size * 0.8, snow.rotation, colorWithOpacity, snow.type);
                }
            };

            // クリックイベントの処理
            document.addEventListener('click', (e) => {
                const x = e.clientX;
                const y = e.clientY;

                // クリック位置に雪を生成
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => {
                        createSnow(x + (Math.random() - 0.5) * 50, y);
                    }, i * 100);
                }
            });

            // アニメーションループ
            const animate = () => {
                updateLeaves();
                updateGroundLeaves();
                requestAnimationFrame(animate);
            };

            animate();
        });
    </script>
</body>
</html>
